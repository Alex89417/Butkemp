/* 
Типы алгоритмов:
1. Константные O(1) - O(2)
2. Логарифмические - Бинарный поиск
3. Линейные O(n) - O(2 * n)...
4. Линейно - логарифмические - Быстрая сортировка
5. Квадратные - пузырьковая сортировка, сортировка выбором, сортировка вставками
6. Кубические - трехмерные массивы
 */

// Напишите программу которая считае сумму от 1 до N.     -->    1 и 3 тип алгоритма!!!

/* int SumNumbers(int N)
{
    int sum =  0;
    for (int i = 1; i <= N; i++)
        sum += i; 
    return sum;
}
Console.Write("Input number: ");
int N = int.Parse(Console.ReadLine()!);
//int N = Convert.ToInt32(Console.ReadLine());

Console.Write(SumNumbers(N)); */

/* Console.Clear();
Console.Write("Введите число: ");
int N = int.Parse(Console.ReadLine()!), result = 0;
for (int i = 0; i <= N; i++)
    result += i;
Console.WriteLine($"Сумма чисел от 1 до {N} = {result}"); */

/* Console.Clear();
Console.Write("Введите число: ");
int N = int.Parse(Console.ReadLine()!); //можно поменять сдесь на дабл: double N = int.Parse(Console.ReadLine()!);
Console.WriteLine($"Сумма чисел от 1 до {N} = {(1 + N) / 2 * N}"); // или сдесь Console.WriteLine($"Сумма чисел от 1 до {N} = {(1 + N) / 2.0 * N}"); */


// Бинарный поиск(двоичный поиск)(делем пополам!!!)   --> 2 тип алгоритма!!!!
// Загаданное число равно 67
// от 1 до 100
// (1+100/2) Число больше 50? - Да (от 50 до 100)   
// (50+100/2) Число больше  75? - Нет (от 50 до 75)   
// (50+75/2) Число больше  62? - Да (от 62 до 75)   
// (62+75/2) Число больше  68? - Нет (от 62 до 68)   
// (62+68/2) Число больше  65? - Да (от 65 до 68)   
// (65+68/2) Число больше  66? - Да (от 66 до 68)  
// Число боьше 67? - Нет (Ответ 67) (т.к. число меньше 68 и больше 66) 
// 7 попыток

// Сложность алгоритма бинарного поиска равен O(log(n))
// log2(1000) ~ 10 (Число из 1000 ищется за 10 папыток)

// [32, 34, 65, 1, 36, 34, 6, 1, 332, -34, 65, 21, 342, 324, 65, 15,] где n - кол-во элементов массива
// O(n * log2(n)) + O(log2(n))


// Быстрая сортировка O(n * log2(n))  - (Рекурсивный подход)
// [34, -10, 23, 5, 2, 1]    
// 1. Выбирается опорный элемент (в основном берется первый элемент массива)
// 2. Создоется 2 массива: 1-й массив содержит элементы меньше опорного
//                         2-й массив содержит элементы больше или равные опорному

// Опорный элемент равен 34
// [-10, 23, 5, 2, 1] + [34] + []           [-10, 1, 2, 5, 23, 34]

// Опорный элемент равен -10
// [] + [-10] + [23, 5, 2, 1]               [-10, 1, 2, 5, 23]

// Опорный элемент равен 23
// [5, 2, 1] + [23] + []                    [1, 2, 5, 23]

// Опорный элемент равен 5              
// [2, 1] + [5] + []                        [1, 2, 5]

// Опорный элемент равен 2  
// [1] + [2] + []                           [1, 2]
